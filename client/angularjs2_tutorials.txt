angularjs2
利用类型实现依赖注入，并使用装饰器来提供元数据

@NgModule元数据:
@declarations:声明哪些组件、指令、管道属于该模块。

@exports公开某些类，以便其它的组件模板可以使用它们。

@imports导入其它模块，从其它模块中获得本模块所需的组件、指令和管道。

@providers在应用程序级提供服务，以便应用中的任何组件都能使用它。


服务提供者:
 可以在组件中提供它。 但是那样一来，它的作用范围就会仅局限于该组件及其子组件。 如果我们希望让该服务与其它和服务有关的组件中共享，我们应该添加其到模块的元数据providers列表中。
 
全应用范围的提供商
ContactService的提供商是全应用范围的，这是因为 Angular 使用该应用的根注入器注册模块的providers。

从架构上看，ContactService属于“联系人”这个业务领域。 其它领域中的类并不需要知道ContactService，也不会要求注入它。

我们可能会期待 Angular 提供一种模块范围内的机制来保障此设计。 但它没有。与组件不同，Angular的 模块实例并没有它们自己的注入器，所以它们也没有自己的供应商范围。
Angular是故意这么设计的。 Angular的模块设计，主要目的是扩展应用程序，丰富其模块化能力。

在实践中，服务的范围很少会成为问题。 联系人之外的组件不会意外注入ContactService服务。 要想注入ContactService，你得先导入它的类型。 而只有联系人组件才会导入ContactService类型。


指令冲突
当两个指令在同一个元素上争相设置颜色时，后声明的那个会胜出，因为它对 DOM 的修改覆盖了前一个

特性模块
特性模块是带有@NgModule装饰器及其元数据的类，就像根模块一样。 特性模块的元数据和根模块的元数据的属性是一样的。
根模块和特性模块还共享着相同的执行环境。 它们共享着同一个依赖注入器，这意味着某个模块中定义的服务在所有模块中也都能用。

我们还用CommonModule替换了BrowserModule，

exports

用路由器实现惰性加载

实际上，SharedModule本身所声明的组件没绑定过[(ngModel)]，那么，严格来说SharedModule并不需要导入FormsModule。

这时SharedModule仍然可以导出FormsModule，而不需要先把它列在imports中。

不要在共享模块中把应用级单例添加到providers中。 否则如果一个惰性加载模块导入了此共享模块，就会导致它自己也生成一份此服务的实例。




Angular HTML 表单模板。

带有@Component装饰器的表单组件类。

通过绑定到NgForm.ngSubmit事件属性来处理表单提交。

模板引用变量，例如#heroForm和#name。

[(ngModel)]语法用来实现双向数据绑定。

name属性的用途是有效性验证和对表单元素的变更进行追踪。

指向 input 控件的引用变量上的valid属性，可用于检查控件是否有效、是否显示/隐藏错误信息。

通过绑定到NgForm的有效性状态，控制Submit按钮的禁用状态。

定制 CSS 类来给用户提供无效控件的视觉反馈。


路由器状态:
在导航时的每个生命周期成功完成时，路由器会构建出一个ActivatedRoute组成的树，它表示路由器的当前状态。 我们可以在应用中的任何地方用Router服务及其routerState属性来访问当前的RouterState值。

重定向路由需要一个pathMatch属性，来告诉路由器如何用URL去匹配路由的路径，否则路由器就会报错。
通过在AppModule中导入AppRoutingModule并再次导出RouterModule，那些声明在AppModule中的组件就可以访问路由指令了，比如RouterLink 和 RouterOutlet。
由特性模块提供的路由会被路由器再组合上它们所导入的模块的路由。 这让我们可以继续定义特性路由模块中的路由，而不用修改主路由配置
路由配置的顺序很重要。 路由器会接受第一个匹配上导航所要求的路径的那个路由。
在这个例子中，我们订阅了路由参数的Observable对象。 这种写法暗示着这些路由参数在该组件的生存期内可能会变化。


路由守卫
守卫返回一个值，以控制路由器的行为：

如果它返回true，导航过程会继续

如果它返回false，导航过程会终止，且用户会留在原地。

